Стейтмашина использующая доктрину2 в качестве инструмента хранения/получения алфавита состояний, алфавита действий и графа переходов

Особенности:
1) граф переходов хранится в БД
2) для хранения состояний используются любое из полей самой ентити, являющееся ссылкой на словарь имеющий метод getId()
3) в качестве алфавита действия используется любая сущность, являющаяся словарем и имеющая метод getId()
4) возможность добавлять усовия доступности перехода (действия над сущностью в конкретном состоянии)
5) возможность перехода в разные состояния в результате одного действия в зависимости от условия.
6) возможность навешивания функторов-обработчиков перед изменением состояния и после него.

================================
Внутреннее устройство
Для работы стейтмашины необходимо иметь:
- словарь состояний
- словарь действий
- граф переходов

Ентити, обслуживаемая стейтмашиной, должна иметь поле состояния с внешним ключем к словарю состояний.

Граф переходов из состояния в состояние описывается парой таблиц (A,B) соединенных отношением 1 к многим.
В А-таблице есть:
 - текущее состояние (внешний ключ к словаря состояний)
 - действие (внешний ключ к словарю действий)
 - условие для выполнения действия (имя класса валидатора)
В B-таблице есть:
 - новое состояние
 - условие перехода в него (имя класса валидатора)
 - приоритет рассмотрения перехода
 - класс-метод(функтор), который будет выполнен перед сменой состояния
 - класс-метод(функтор), который будет выполнен после смены состояния

Движение по графу переходов для ентити осущетсвляется путем вызова метода doAction у стейтмашины, которому передается
- действие
- объект (ентити, над которой собираемся выполнить действие)
- дополнительный массив данных
Стейтмашина проверяет наличие действия как такового для объекта в текущем состоянии.
При наличии действия проверяется выполнение условия для выполнения действия.
Если действия нет или условие не выполняется, то генерируется
исключение о том, что действие недоступно.

После прохождения контроля на доступность действия определяется, каким будет новое состояние на основании B-таблицы.
Новые состояния рассматриваются в порядке приоритета рассмотрения перехода. При этом проверяется условие.
Первый подошедший переход определяет новое состояние и пре и пост функторы, которые будут при этом выполнены.
Если ни один из условных переходов (у которых задано условие) не прошел по условию, то будет выполнен переход,
у которого условие - NULL

Условия в A-таблице и B-таблицы задаются с помощью валидаторов.
Рекомендуется для задания условия наследоваться от ValidatorChain , чтобы список необходимых проверок
можно было легко расширять

Описание собственной стейтмашины для новой ентити
================================
- В ентити определяем аттрибут-поле, которое будет содержать состояния.
- Создаем словарь состояний. Для удобства id словаря по возможности делаем строчным (визуально удобней при просмотре БД).
- Создаем словарь действий, для удобства id делаем строчным.
- Создаем A-таблицу и B-таблицу, связанную с A-таблицей через поле transition_a_id
- Создаем класс, пронаследованный от StateMachine\Service\StateMachine, где задаем
    protected $transitionAClassName = <имя ентити A-таблицы >;
    protected $transitionBClassName = <имя ентити A-таблицы >;
    protected $actionDictionary = <имя словаря действий>;
    protected $stateAttribute = <имя атрибута в ентити, который содержит состояния>;

Изначально предполагалось, что словарь переходов общий для всех стейтмашин. В этом случае ентити таблицы переходов
должна содержать атрибут code, который уникален в пределах стейтмашины
Но если Вы делаете на каждую стейтмашину свой словарь переходов согласно рекомендациям выше, тогда
переопределите в своей стейтмашине метод получения действия, например следующим образом:
protected function getActionEntity($action)
{
    $repo = $this->getEntityManager()->getRepository($this->actionDictionary);
    return $repo->findOneBy(['id' => $action]);
}

